# defaults
require "irb/completion"

gems = %w[rubygems ap ruby-debug interactive_editor]
gems.each do |gem_name|
  begin
    require gem_name
  rescue LoadError
    puts "=> Unable to load #{gem_name}"
  end
end

require "active_support/all" unless defined?(ActiveSupport)

IRB::Irb.class_eval do
  def output_value
    ap @context.last_value
  end
end if defined?(AwesomePrint)

# history
IRB.conf[:SAVE_HISTORY] = 100
IRB.conf[:HISTORY_FILE] = File.expand_path("~/.irb_history")
IRB.conf[:EVAL_HISTORY] = 100

if File.file?(IRB.conf[:HISTORY_FILE])
  lines = File.readlines(IRB.conf[:HISTORY_FILE]).collect do |line|
    line.gsub(/^p */, "").chomp
  end

  Readline::HISTORY.push(*lines)
end

at_exit do
  lines = Readline::HISTORY.to_a.uniq
  lines = lines.reject {|l| %w[c exit l nil irb].include?(l) }

  count = lines.count
  start = [count - IRB.conf[:SAVE_HISTORY], 0].max
  lines = lines[start, IRB.conf[:SAVE_HISTORY]]

  File.open(IRB.conf[:HISTORY_FILE], "w+") do |file|
    file.flock(File::LOCK_EX)
    file.puts(lines)
    file.flock(File::LOCK_UN)
  end
end

# prompt
prompt = "#{RUBY_VERSION}"

IRB.conf[:PROMPT][:CUSTOM] = {
  :PROMPT_I =>"#{prompt} >> ",
  :PROMPT_N =>"#{prompt} >> ",
  :PROMPT_S =>"#{prompt} >> ",
  :PROMPT_C =>"#{prompt} ?> ",
  :RETURN   =>"=> %s\n"
}

IRB.conf[:AUTO_INDENT]  = true
IRB.conf[:PROMPT_MODE] = :CUSTOM

# rails
ActiveSupport.on_load(:active_record) do
  ActiveRecord::Base.logger = Logger.new(STDOUT)
  ActiveRecord::Base.instance_eval { alias :[] :find }
end

ActiveSupport.on_load(:after_initialize) do
  env = {"development" => :dev, "production" => :prod}.fetch(Rails.env, Rails.env)
  prompt = "#{env}##{RUBY_VERSION}"

  IRB.conf[:PROMPT][:RAILS] = {
    :PROMPT_I =>"#{prompt} >> ",
    :PROMPT_N =>"#{prompt} >> ",
    :PROMPT_S =>"#{prompt} >> ",
    :PROMPT_C =>"#{prompt} ?> ",
    :RETURN   =>"=> %s\n"
  }

  IRB.conf[:PROMPT_MODE] = :RAILS

  at_exit do
    Dir["log/**/*.log"].each do |file|
      system "> #{file}"
    end
  end
end

# utils
# Display methods added by this object.
#
def m(object)
  (object.methods - object.class.superclass.instance_methods).sort
end

